Интеграция проектов apress с node.js и webpack
==============================================

TL;DR
-----

Все это нужно для того, чтобы начать использовать современные инструменты из мира фронтенда более нативным способом -
с помощью node.js, yarn, webpack.

Предполагается, что в дальнейшем можно будет полностью отказаться от сборки ассетов средствами рельсов (Sprockets) и
использовать только вебпак. Пока сборки живут параллельно друг другу и не пересекаются.

Сейчас вебпак работает на всех наших проектах (ПЦ, Близка, Япок) и во всех средах (докер, тестовые, санчез, нож,
продакшн).

Но, также, есть и ряд нерешенных проблем и планов на будущее по улучшению удобства использования.

Содержание
----------

- [Введение](#Введение)
- [Детали реализации](#Детали-реализации)
  - [Проекты](#Проекты)
  - [Гемы](#Гемы)
- [Работа в средах](#Работа-в-средах)
  - [Docker](#docker)
  - [Knife](#knife)
  - [Son4](#son4)
  - [Продакшн и тестовые](#Продакшн-и-тестовые)
- [Нерешенные проблемы](#Нерешенные-проблемы)


Введение
--------

Само по себе добавление в инфраструктуру современных frontend инструментов не решит архитектурных проблем организации
ассетов. Все современные фреймворки, методологии, стандарты движутся в сторону компонентной модели для организации
ассетов. Т.е. приложение разделяется на отдельные неделимые функциональные блоки, которые объединяют в себе и js и css
и верстку. У нас же, глобально, никакой компонентной модели в организации ассетов нет, повсеместно встречаются
километровые портянки css'a или js'a в которых собран весь функционал целой страницы или нескольких страниц.

Поэтому внедрение современного frontend'a стоит рассматривать как первый этап на пути решения данных проблем. В
частности это позволит:

* уменьшить связанность технологий при разработке фронтeнда и бэкенда;
* использовать современные, нативные для фронтенда, инструменты для тестирования, инструментирования, транспилирования,
  сборки, хранения и доставки;
* подготовить фундамент для внедрения новых архитектурных подходов в разработке (фреймворки, методологии).


Все работает на платформе [Node.js](https://nodejs.org/en/).

В качестве менеджера пакетов используется [yarn](https://yarnpkg.com/lang/en/).

Сборка ассетов - [webpack](https://webpack.js.org/concepts/).


Детали реализации
-----------------

Ассеты, собранные вебпаком живут параллельно ассетам, собранным sprockets и на уровне кода не пересекаются, но имеют
общий рантайм. Это значит, что мы не можем подключить внутри вебпак сборки js-модуль, который собирается sprockets'ом,
но мы можем послать из него событие (например, `$element.trigger...`) которое будет доступно внутри модулей, собранных
вебпаком.

Весь новый фронтенд живет максимально изолированно от остального проекта (или гема).

Мы используем возможности node.js только в качестве инструментов для разработки (webpack) и подтягивания
фронтенд-зависимостей (jquery-плагины и прочее). В продакшене нет никакого node.js инстанса для серверного рендеринга и
прочего.



### Проекты

* [Пулл-реквест с переводом проекта на Webpack](https://github.com/abak-press/pulscen/pull/17423)

термины:

* `СФИ`  - современные фронтенд инструменты (node.js, yarn, webpack)
* `RoR ` - Ruby on Rails

На уровне проекта (близко, пц, япок) для интеграции RoR с СФИ используется официальный rails гем
[webpacker](https://github.com/rails/webpacker). Так как из коробки Webpacker требует `rails 4.2+`, то в проекты мы
подключаем наш адаптированный под rails 3.2+ [форк](https://github.com/abak-press/webpacker).

Для подтягивания в проект собранных гемных ассетов из npm-пакетов, которые находятся в нашем приватном registry
используется следующее решение:

На проекте есть локальный проектный `package.json` (`package.local.json`) и утилита, которая парсит `gemfile.lock`
и на основе своего конфига, в котором указано какие гемы имеют npm-пакеты, а также версии гема, строит новый
`package.json`, в который включены пакеты с гемными ассетами.

* пример локального проектного [`package.json`](https://github.com/abak-press/pulscen/blob/master/package.local.json) -
  тут задаются нужные проекту js-зависимости. Здесь не задаются зависимости от наших гемов с npm-пакетами, только
  общедоступные пакеты из публичного registry, либо утилиты из нашего приватного registry.

* [утилита](https://github.com/abak-press/pulscen/blob/master/script/package.js) для формирования конечного
  `package.json` файла. [В этот массив](https://github.com/abak-press/pulscen/blob/master/script/package.js#L9)
  добавляем названия гемов, которые имеют npm-пакеты. Версию гемов указывать не нужно, она автоматически вычислится из
  файла `Gemfile.lock`. Важно, чтобы для каждой версии гема был также npm-пакет с такой-же версией. Если гем
  подключается не с версии а с ветки, тогда в npm-registry должна быть версия npm-пакета данного гема в следующем
  формате: `MAJOR.MINOR.PATCH-COMMIT-HASH`, где:
    - `MAJOR.MINOR.PATCH` - версия гема в текущей ветке (можно найти в `lib/apress/gem-name/version.rb`)
    - `COMMIT-HASH`       - полный хэш коммита, с которого подключен гем.

    Например: `4.9.0-976f7a8eb506c967f909dc10a5e9d22737329739`

* запуск утилиты для формирования конечного `package.json`, установка зависимостей и запуск процесса сборки вебпаком
  в различных средах (docker, son4, knife, prod, staging) производится по разному и описан далее в соответствующих
  [разделах](#Работа-в-средах).


#### Конфигурация Webpack

Конфигурационные файлы находятся в директории `config/webpack/`. Для каждого окружения создается собственный файл с
настройками, например, `config/webpack/development.js`. Файл, содержащий общие настройки для всех окружений -
`config/webpack/environment.js`. Entrypoints хранятся в директории frontend/packs.

Для более удобной отладки можно использовать гибкую настройку
[source-maps](https://blog.teamtreehouse.com/introduction-source-maps) опцией `devtool`. Она будет влять на то,
как код отображается в браузере при отладке. Так, со значением `eval` будет показан код сгенерированный вебпаком, а при
`eval-source-map` - исходный. Для использования `devtool` в development окружении, надо положить нужное значение в
конфиг (`config/webpack/development.js`). Возможные значения `devtool` и их описание можной найти в
[документации webpack](https://webpack.js.org/configuration/devtool/#devtool).
Там же есть [рекомендации по использованию опции для отладки](https://webpack.js.org/configuration/devtool/#development).

Пример `config/webpack/development.js` с опцией `devtool`

```
const environment = require('./environment');

const config = environment.toWebpackConfig();
config.devtool = 'eval-source-map';
module.exports = config;
```

`devtool` назначается после вызова `toWebpackConfig()`.

#### Интеграция с RoR

1. В корне проекта есть папка `frontend` в которой есть `packs` - это entry-points, которые автоматически подхватываются
   вебпакером и компилируются в конечные бандлы

  * каждый `entry-point` можно рассматривать как аналог наших пэкеджей (javascripts/package или stylesheets/package)

2. Эти конечные бандлы подключаются в нужные вьюхи с помощью хелперов *`javascript_pack_tag`* и *`stylesheet_pack_tag`*

  * эти хелперы можно использовать в гемных вьюхах, главное, чтобы на уровне проекта лежал entry-point, который вызываем
    из гемной вьюхи.

3. Так как наша утилита `script/package.js` подхватила npm-пакеты из гемов, то мы легко можем  подключать их в эти
   entry-points или даже создавать новые, вебпакер подхватит их автоматически.


### Гемы

На уровне конкретного гема нет webpacker'a. Но для единообразия можно использовать похожие концепции.

1. В корне гема есть папка `frontend` в которой находится абcолютно все фронтовое: package.json, конфиги вепака и пр.,
   папка `packs` с entry-point'ами гема, все исходники. Туда же устанавливаются зависимости, собираются бандлы. Такой
   подход позволит исключить размазывание фронтовых файлов по директориям гема.

  * хотя на уровне проекта пока не удалось добиться того же - чтобы все фронтовое было в папке frontend. Но это
    обусловлено особенностями реализации гема `webpacker` и связанного с ним npm-пакета `@rails/webpacker`.

2. В геме каким-либо образом фиксируется, какие entry-point'ы нужно добавить в проект при подключении, либо какие
   бандлы нужно подключить в существующие проектные entry-point'ы. Сейчас это сделано на уровне README.md.

3. Под гитом сгенерированные гемные ассеты не хранятся, но хранятся в npm-registry. Таким образом мы можем сразу
   отдавать вебпакеру собранные бандлы.

4. Если нужно дебажить гем (этот шаг можно автоматизировать до одной команды + автоматически выполнять при
   `dip provision`, но пока работает так):

    * подключаем гем локально
    * добавляем в `package.js` название гема
    * прогоняем: `dip sh` `node script/package.js` чтобы сгенерировать результирующий проектный `package.json`
    * устанавливаем зависимости: `dip sh` `yarn install`
    * линкуем локальный гем в node modules: `dip sh` `yarn run linklocal`
    * на уровне гема вносим любые изменения в ассеты и пересобeраем их
    * на уровне проекта ассеты пересоберутся автоматически
    * проверяем, что на уровне проекта есть entry-points:
       * Например, локально подключаем гем `apress-eti`. В проекте, в папке `frontend/packs` создаем директорию с именем гема (`frontend/packs/apress-eti/assets`) где и размещаем package со сборкой (например, назовем ее common.js)
       и импортим в нем сборку:
       ```
       import '@apress/apress-eti/build/assets-eti.js';
       ```
       Этот entry-points (`frontend/packs/apress-eti/assets/common.js`) указываем в геме для подключения:
       ```
       = javascript_pack_tag 'apress-eti/assets/common', defer: true
       ```
примеры переводов гемов:

* https://github.com/abak-press/apress-regions/pull/68
* https://github.com/abak-press/apress-visited_products/pull/16
* https://github.com/abak-press/apress-companies-communications/pull/31


#### Перевод legacy-ассетов на вебпак

При интеграции гемов с legacy-ассетами решались следующие проблемы:

  * компиляция scss - решилась добавлением вебпака с нужными loader'ами.

  * сборка js - ничего делать не нужно, вебпак автоматом подхватывает наши модули

  * hamlbars - заменил на handlebars, который предкомпилируется вебпаком.

  * локали в js темплейтах - в рантайме есть конфиг app.i18n, в котором есть все локали, которые могут использоваться в
    handlebars. Внутри шаблона получается путем вызова хелпера. Хелпер лежит в отдельном npm пакете, который
    можно расширять и подключать в нужные места как package.json зависимость

  * инлайн svg в scss - решил с помощью `base64-inline-loader`. Картинки в scss подключаются по ссылке, а при сборке
    вебпак инлайнит их в base64. Это позволит держать подключаемые картинки отдельно от scss и нормально с ними работать,
    сейчас же у нас все картинки лежат в виде кода в scss. Но есть минус - если нам нужна одна и та же картинка, но
    другого цвета, то нужно держать обе эти картинки и добавлять к имени ее цвет. Но от этого можно уйти путем добавления
    в svg классов, которыми можно управлять из css.

  * `erb` префикс в имени ассетов - в каждом случае нужно решать по своему. В самом просто случае, `erb` используется для
    задания пути к картинке, тут все просто - заменяем ее на обычную относительную ссылку. но есть и более сложные
    варианты, по каждому случаю нужно думать отдельно пути решения.

#### Зависимости гемных ассетов

гемные ассеты могут подключаться:

  * внутри гемных вьюх. В этом случае на уровне проекта нужно создать entry-point гема, в который подключить его ассеты.

    Если у гема есть внешние зависимости от ассетов другого гема, то до тех пор, пока эти зависимости
    не переведены на новый фронтенд (вебпак), оставлять их в `app/assets/{js|scss}/package/{name}` и подключать в
    гемных вьюхах рядом с подключением вебпаковских сборок.

  * Внутри проектных вьюх и пекеджей. В этом случае на уровне проекта подключаем гемные ассеты в существующие проектные
    entry-point'ы.

    Тогда зависимости гема нужно резолвить на стороне проекта. При этом также, если эти зависимости
    уже переведены на вебпак, то подключать их в тот же entry-point что и подключаемый гем, либо в
    `app/assets/{js|scss}/package/{name}`, который также будет подключаться рядом с подключением вебпаковских сборок.

#### Публикация гема

Перед тем, как добавлять/удалять пакеты из npm-registry, необходимо получить к нему доступ. Доступ можно получить у
админов. После получения доступа, необходимо авторизоваться: `sudo npm adduser --registry https://registry.railsc.ru`.

Для того, чтобы гем появился в приватном [registry](registry.railsc.ru), необходимо собрать и опубликовать npm-пакет:

1. `sudo npm run build`   - сборка пакета вебпаком (необходимо убедиться, что в `package.json` есть нужная команда `build`, находиться нужно в папке /frontend)
2. `sudo npm publish` - публикация пакета в приватном registry.

Если нужно изменить версию выпускаемого пакета: `sudo npm version <new version>` [Документация](https://docs.npmjs.com/updating-your-published-package-version-number)

Если необходимо удалить пакет - `npm unpublish --force`. Будьте внимательны и не удаляйте лишнего, изменения необратимы.

Особенности выпуска npm-пакета: если ветка, в которой велась разработка требует master/других веток, то после мерджа этих веток в текущую npm-пакет нужно выпускать снова.
При выпуске npm-пакета нужно указывать версию:
- самого гема, если мы выпускаем npm-пакет из master
- версию гема и hash последнего коммита в ветке, если мы выпускаем пакет из ветки. Т.е., например, версия гема в ветке 1.0.0, hash последнего коммита `b667227ebaaf13c5e14234412ba9b83820085f61`, значит выпускаемая версия пакета будет: `1.0.0-b667227ebaaf13c5e14234412ba9b83820085f61`.

В проект подключаем только пакет, выпущенный с master и новой версией гема. Промежуточный выпуск пакета с ветки нам нужен для проверки работоспособности сборки.

**ВАЖНО чтобы версия гема и версия npm пакета всегда совпадали! Поэтому обязательно выпускать версию npm пакета гема, если изменилась версия гема.**

Работа в средах
---------------

### Docker

При разработке в докере сервис с webpack-вотчером запускается автоматически при старте `dip rails s`. Информацию о его
работе можно отслеживать с помощью dip compose logs -f *PROJECT_webpack* (например, `dip compose logs -f pulscen_webpack`).

Запуск `script/package.js`, установка зависимостей и линковка локальных зависимостей происходит автоматические на этапе
`dip provision`.

Также можно выполнять любые манипуляции с nodejs, yarn, webpack зайдя в app контейнер `dip sh`.

### Knife

Сборка вебпак-ассетов на ноже происходит автоматически при запуске стенда. Ассеты начинают компилироваться после
выполнения assets:precompile таска (примерно 5-6 минут после успешного запуска стенда).

### Son4

Для того, чтобы запустить вебпак в режиме вотчера:

```
export NODE_ENV=develop;
node script/package.js;
yarn install;
yarn run watch;
```

### Продакшн и тестовые

Сборка вебпак-ассетов происходит автоматически при деплое. Алгоритм сборки:

* после `assets:precompile` запускается генерация  `package.json` и установка зависимостей
  (https://github.com/abak-press/pulscen/blob/master/lib/tasks/webpacker.rake);

* затем сборка вебпака (запускается из гема Webpacker);

* затем копирование собранных ассетов на все машины
  (https://github.com/abak-press/pulscen/blob/master/lib/capistrano/webpack.rake)

Нерешенные проблемы
-------------------

1. Наше приватное npm-registry (registry.railsc.ru) пока что доступно из интернета. Необходимо настроить права доступа.

2. Нужно настроить CI-систему так, чтобы при выпуске новой версии гема, автоматически выпускался новый npm-пакет.

3. `script/package.js` нужно оформить как отдельный репозиторий и npm пакет, и развить его идею:

  * избавить от собственного конфига внутри package.js. Вместо этого идентифицировать гемы, у которых есть npm пакеты по
    группе `with_npm_package`. Например: `gem apress-eti :group => [:with_npm_package]`;

  * добавить в каждый гемный npm пакет конфиг, в котором указывать, какие entry-point'ы нужно создать в проекте для
    этого пакета.
